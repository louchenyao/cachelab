# Part A

根据题目要求，实现。有一个技巧是`L`和`S`相当于一次访存，`M`相当于两次访存。所以`L`和`S`会调用一次`cache`函数，`M`调用两次。

# Part B

## 32x32

用于传入csim的参数为s=5, E=1, b=5。每个block的大小为32，可以存8个int。共32个set，每个set只有1行。所以从直觉上来看，分成8x8的小块或者16x16分别做转置可能是个不错的解法。但是分成8x8对于32x32的矩阵miss次数为343，分成16x16时对于32x32的矩阵miss次数为1183（和sample一样）。

我通过利把trace文件中每个地址的set和tag打印出来发现，分成16x16时没有优化的原因是因为矩阵第一列地址的set为`0,4,8,...,28,0,4...`，所以最多只能存8行不同的！当写到第9行时候，会把第1行的给踢出缓存，相当于写时候根本没有利用到缓存。

分成8x8时，有的时候读的地址的set和写入时候的地址的set恰好一样，这就导致了`B[i][j] = A[j][i]`这句话会产生多次miss（踢出B读取A，踢出A存入B，下一个语句的时踢出B读取A）。所以每次直接读取一整行，放入寄存器中，减少这种原因导致的miss。

## 64x64

和32x32类似，每一个列set的地址为`0,8,16,0,8...`，所以选用4x4分块的效果应该不错，miss次数为1891。另外一个优化的技巧是考虑先分成8x8的块。再把8x8的分成4x4的小块。然后按照下面顺序计算

 - 把A左上角的4x4的块转置放入B左上角 (A miss 4次, B miss 4次)
 - 把A右上角的4x4的块转置后入B**右上角** （没有miss)
 - 读取B的右上角一行，存入临时变量。把A左下角一列读取存入B右上角的对应行，把临时变量存入B右下角对应行 (A miss 4次，B miss 4次)
 - 把A右下角的4x4的块转置后放入B左下上角 （没有miss)

如果不考虑A和B之间的冲突的话，只需miss 16次即可完成8x8矩阵的转置。之前需要24次。

## 61x67

由于长和宽都为质数，所以一列的set会每32次出现一个重复，所以可以直接使用分块即可。但是无论分块大小为多大，每一块内相邻的两个元素都有可能不在一个block里。经过测试16可以通过测试。